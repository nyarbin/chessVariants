%
% File naaclhlt2010.tex
%
% Contact: nasmith@cs.cmu.edu

\documentclass[11pt,letterpaper]{article}
\usepackage{naaclhlt2010}
\usepackage{times}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{tikz}
\setlength\titlebox{6.5cm}    % Expanding the titlebox

\title{TITLE HERE}

\author{Ben Reis \\
  ADDRESS \\
  {\tt email}
  \And
  Andrew Zhu \\
  Johns Hopkins University \\
  3700 N. Charles St. \\
  Baltimore, MD 21218, USA\\
  {\tt azhu8@jhu.edu}}

\date{}

\begin{document}
\maketitle
\begin{abstract}
General Game Playing (GGP) programs can learn to play any game it is given a description for. In our project, we aim to use these programs to help generate fun and balanced variants of chess. Our system generates descriptions of these variants using the Game Description Language (GDL). By analyzing gameplay results between pairs of GGP players, and by using genetic algorithms to build variants stochastically, our system is able to traverse the search space of chess variants to find one that is hopefully enjoyable.
\end{abstract}

\section{Introduction}
%Intro here - what's the problem?
% talk about GDL, METAGAME, automated game design
Automated game design is a relatively new topic in artificial intelligence
research. %TODO more here

% Discussion of goals re: interesting+balanced games; (read and) cite AGD
% paper(s).
% Some simple discussion of GGP and general game analysis

We focus on chess because it is a good model of a larger genre of positional
strategy games, which are both interesting to humans and easily amenable to
generic analysis, potentially by computers. Principles developed for creating
and balancing variants of chess can then be generalized and expanded to cover
a much wider field of games.

\section{Encoding Chess-Like Games}
%define a ride!
%define symmetries from metagame

Researchers in automated game design are presently focused on short, simple
videogames with few rules. As far as we know, it has been many years since
someone attempted to construct a system for generating chess-like games, and the
only language we could discover for encoding such games is no longer being
maintained.

On the analysis side of things, an extension of Datalog called the Game
Description Language has become the standard language for formally specifying
games in a manner that can be understood by generic computer players. As there
are a number of existing players and masters that make use of GDL, we decided to
use it as well.

% Discussion of Metagame terminology (possibly break into sidebar?)
As discussed in \cite{agd1}, Pell \cite{metagame} did a great deal of work to
define "chess-like" games formally, in his Metagame workbench for general game
players. While we did not use the specification language he defined, his
terminology and mathematical work was quite useful. The key terms used here are
described below.

\begin{description}
   \item [Direction Vector] A direction vector \(\langle x,y \rangle\) is simply
      a vector over the chessboard. \(x\) represents a difference in file and
      \(y\) represents a difference in rank. A positive vector represents a move
      away from white and to white's right. For example, one of a knight's
      possible moves can be described by \(\langle 1,2 \rangle\), and a white
      pawn's standard move is in the direction \(\langle 0,1 \rangle\).
   \item [Symmetry] Pell defines \textit{forward}, \textit{side}, and
      \textit{rotation} symmetries for his vectors. \textit{Forward} and
      \textit{side} symmetries negate the \(y\) and \(x\) values of the vector,
      respectively, while the \textit{rotation} symmetry swaps them.
   \item [Leap] A leap describes a move where intervening squares on the board
      do not matter; only the destination square has any effect on the move's
      legality, and only the destination can be affected.
   \item [Ride] A ride is a series of leaps in a particular direction, sometimes
      with a maximum number of repetitions. All squares between the start and
      the end of a ride must be empty. A pawn's first-turn move is a ride with
      length \(2\).
   \item [Hop] A hop is a ride where some of the squares must be contain a
      piece, possibly of a specific type.
\end{description}
% End Metagame stuff

\section{Search Algorithms}
Genetic algorithms seemed like a good fit with the simulation based strategy that we picked: both genetic algorithms and the simulations involve randomness in their execution. Because our chess variants have different movements rules for individual pieces, we created an encoding of these movement rules. This encoding is then stochastically mutated and recombined with other encodings during the iterations of the algorithm.

We encode each chess variant to be a set of pieces. Because the game players are responsible for actually placing the pieces on the board (see the Implementation section), our encoding only deals with the movement rules of those pieces. Each piece in a variant has a list of movement rules (squares a piece can move into if not capturing a piece) and a list of capture rules (squares a piece can move into if capturing an enemy piece). Each of these rules consists of a direction vector, a ride length, and a list of symmetries that the rule is subject to.

Here are some ways that regular chess pieces would be encoded:\\
\begin{center}
Knight (Figure 1)
\end{center}
\begin{figure}
\centering
\includegraphics[width=6cm]{knight.jpg}
\caption{Knight Movement}
\label{fig:boat1}
\end{figure}
Movement Rules:
\begin{enumerate}
\item direction:(1,2),\\
rideLength:1,\\
symmetries:[SIDE, FORWARD, DIAGONAL]
\end{enumerate}
Capture Rules:
\begin{enumerate}
\item direction:(1,2),\\
rideLength:1,\\
symmetries:[SIDE, FORWARD, DIAGONAL]
\end{enumerate}

\begin{center}
Queen
\end{center}
Movement Rules:
\begin{enumerate}
\item direction:(1,0),\\
rideLength:7,\\
symmetries:[SIDE, DIAGONAL]
\end{enumerate}
Capture Rules:
\begin{enumerate}
\item direction:(1,1),\\
rideLength:7,\\
symmetries:[SIDE, DIAGONAL]
\end{enumerate}

Recall that diagonal symmetry is symmetry over the $y=x$ axis. This allows the knight movement rule to be encoded simply as one move with all 3 kinds of symmetry. Also recall that a ride is defined as consective movements where no intervening square is occupied, except for perhaps the last square on a capture move. The queen can traverse the entire board if not blocked, so she has a ride length of 7 to represent 7 consecutive movements in the direction (1,0) or (1,1). Both of the examples here have the same rules for capture and movement. A pawn would have two different rules in order to encode that a pawn can move forward if not blocked by another piece, and can only capture diagonally. Every piece in our encodings has side symmetry (across the $y$ axis) for aesthetic reasons.

When running the algorithm, there are $N$ surviving variants after a round of selection. During the generation phase, we generate an additional $N$ candidate variants for the next round using mutation and recombination. A candidate is mutated by adding new pieces to its set of pieces, by deleting pieces, or by changing the movement rules of its existing pieces. Two candidates are recombined into a new candidate by picking randomly among the two parents' pieces to create a new set of pieces. The original $N$ variants also remain in the pool of survivors, unchanged.

After the generation phase comes the selection phase, where candidates are evaluated using the GGP players, and then some candidates are thrown out before the next generation phase. In keeping with the spirit of games, we decided to use tournament selection to select $N$ survivors from the $2N$ candidates. A fitness score is calculated for each candidate based on the results from the GGP players, and then candidates are randomly paired with each other. The candidate with the higher fitness score in each pair is selected to survive. Note that in this scheme, the candidate with the best fitness score will always survive, and candidates with higher scores are more likely to survive, but not guaranteed.

\section{Implementation}
% Decided to have players place pieces to simplify game generation.

\subsection{Generating Pieces}
% talk about balance decisions

\subsection{Encoding the Game}
% talk about encoding decisions in GDL
% cite speedchess; alloyGGP
Encoding chess in GDL presents a number of problems due to the complexity of the
game's state, which involves a great deal of information on which pieces have
moved at all (for pawn moves and castling) and which pieces might move to
certain places (for check and related concepts). All of this is in addition to 

\section{Results}

\section{Discussion}


\section{Comparison to Proposal}


\section{Conclusion}



\begin{thebibliography}{}

\bibitem[\protect\citename{Srivastava et al.}2014]{Srivastava:14}
Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov.
\newblock 2014.
\newblock Dropout: A Simple Way to Prevent Neural Networks from Overfitting. {\em Journal of Machine Learning Research},15(2014):1929-1958.

\bibitem[\protect\citename{Nielson}2015]{Nielson:15}
Michael Nielson.
\newblock 2015.
\newblock Neural Networks and Deep Learning. {\em Determination Press}.
\newblock http://neuralnetworksanddeeplearning.com

\bibitem[\protect\citename{RGU}]{RGU}
Robert Gordon University.
\newblock The Backpropagation Algorithm.
\newblock https://www4.rgu.ac.uk/files/chapter3\%20-\%20bp.pdf

\bibitem[\protect\citename{Repo}2013]{Repo:13}
M. Lichman.
\newblock UCI Machine Learning Repository.
\newblock University of California, School of Information and Computer Science.
\newblock https://archive.ics.uci.edu/ml
\end{thebibliography}

\end{document}
